<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <style>
    body { margin:0;position:fixed;top:0;right:0;bottom:0;left:0; }
    .hidden {
        display: none;
    }
    div.tooltip {
        color: #222;
        background-color: #fff;
        padding: .5em;
        text-shadow: #f5f5f5 0 1px 0;
        border-radius: 2px;
        opacity: 0.9;
        position: absolute;
    }
  </style>
</head>

<body>
    <script src="../../../viz/js/data/appchord_model.js"></script>
    <script>
        // Svg variable
        var svg = d3.select("body").append("svg")
                    .attr("width", 1000)
                    .attr("height", 1000);
        
        // Tooltip div
        var tooltip = d3.select('body').append('div').attr('class', 'hidden tooltip');

        function getRandomColor() {
            var letters = '0123456789ABCDEF';
            var color = '#';
            for (var i = 0; i < 6; i++)
                color += letters[Math.floor(Math.random() * 16)];
            return color;
        }

        class AppChord {
            constructor(svg, tooltip, cx, cy, inrad, outrad, max_outrad, alpha) {
                this.svg = svg;
                this.tooltip = tooltip;
                this.cx = cx;
                this.cy = cy;
                this.inrad = inrad;
                this.outrad = outrad;
                this.max_outrad = max_outrad;
                this.alpha = alpha;
            }

            seconds_to_time(sec) {
                let h = Math.floor(sec / 3600)
                let hs = h > 0 ? h + "h " : ""
                sec = sec % 3600;
                let m = Math.floor(sec / 60)
                let ms = m > 0 ? m + "m " : ""
                let ss = (sec % 60) + "s"

                return hs + ms + ss
            }

            app_mouse_move(i, data, apps, times, pathObject) {
                var mousePosition = d3.mouse(pathObject);
                let switches = data[i].reduce(function(a, b) { return a + b; })
                let html = `
                    <b>${apps[i]}</b></br>
                    Usage time : ${this.seconds_to_time(times[i])}</br>
                    Switches : ${switches}`

                this.tooltip.classed('hidden', false)
                    .attr('style', 'left:' + (mousePosition[0] + 15 + this.cx) +
                            'px; top:' + (mousePosition[1] - 35 + this.cy) + 'px')
                    .html(html);
            }

            app_mouse_out(i, colors) {
                let that = this;

                this.tooltip.classed('hidden', true);
                d3.selectAll("path")
                    .transition().duration(500)
                    .filter(d => { return 'source' in d && d.source.index != i && d.target.index != i})
                    .style("fill", d => colors[d.source.index]+that.alpha);
            }

            app_mouse_over(i) {
                d3.selectAll("path")
                    .transition().duration(250)
                    .filter(d => { return 'source' in d && d.source.index != i && d.target.index != i})
                    .style("fill", "#CCCCCC11");
            }

            draw(apps, data, abs_times, colors) {
                // Times normalization
                var that = this;
                var max = abs_times.reduce(function(a, b) { return Math.max(a, b); })
                let times = abs_times.map(d => d/max)

                var res = d3.chord()
                            .padAngle(0.04)     // padding between entities (black arc)
                            .sortSubgroups(d3.descending)
                            (data)

                let group = this.svg.datum(res)
                    .append("g")
                    .selectAll("g")
                    .data(d => { return d.groups; })
                    .enter()
                
                group
                    .append("g")
                    .append("path")
                        .style("fill", function(d, i) { return colors[i]; })
                        //.style("stroke", "black")
                        .attr("d", d3.arc()
                            .innerRadius(this.inrad)
                            .outerRadius(function(d, i) { return that.outrad }))//+ times[i]*that.max_outrad }))
                        .attr("transform", "translate("+this.cx+", "+this.cy+")")
                        .on("mouseover", function(d, i) { that.app_mouse_over(i); })
                        .on("mousemove", function(d, i) { that.app_mouse_move(i, data, apps, abs_times, this) })
                        .on("mouseout", function(d, i) { that.app_mouse_out(i, colors) })

                // Add the links between groups
                this.svg
                    .datum(res)
                    .append("g")
                    .selectAll("path.links")
                    .data(function(d) { return d; })
                    .enter()
                    .append("path")
                        .attr("d", d3.ribbon()
                        .radius(this.outrad - 10)
                        )
                        .style("fill", d => colors[d.source.index]+that.alpha)
                        //.style("stroke", "black")
                        .attr("transform", "translate("+this.cx+", "+this.cy+")")
            }
        }
        
        let xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', '../../../data/dataset.json', true);
        xobj.onreadystatechange = function () {
                if (xobj.readyState == 4 && xobj.status == "200") {
                    let data = JSON.parse(xobj.responseText)
                    let f = d => d['App Name'] != "Screen off" && !d['App Name'].startsWith("Screen on") && d['User_ID'] == 1
                    data = data.filter(f)
                    let acm = new AppChordModel(data)
                    acm.apply_filters(60, 1e10, 0.2, 1)

                    colors = acm.filtered_apps_time.map(d => getRandomColor())
                    ac = new AppChord(svg, tooltip, 500, 500, 300, 340, 120, "BB")
                    ac.draw(acm.filtered_apps,
                            acm.filtered_adj_mat,
                            acm.filtered_apps_time,
                            colors)
                }
        };
        xobj.send(null);
    </script>
</body>
