<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <style>
    body { margin:0;position:fixed;top:0;right:0;bottom:0;left:0; }
    .hidden {
        display: none;
    }

    div.tooltip {
        color: #222;
        background-color: #fff;
        padding: .5em;
        text-shadow: #f5f5f5 0 1px 0;
        border-radius: 2px;
        opacity: 0.9;
        position: absolute;
    }

    .links line {
        stroke: #CCC;
    }

    text {
        font-family: sans-serif;
        font-size: 0.85em;
    }
  </style>
</head>

<body>
    <script src="../../../viz/js/data/appchord_model.js"></script>
    <script>
        // Svg variable
        var svg = d3.select("body").append("svg")
                    .attr("width", 1000)
                    .attr("height", 1000);
        
        // Tooltip div
        var tooltip = d3.select('body').append('div').attr('class', 'hidden tooltip');

        /**
         * Class for AppGraph visualization
         */
        class AppGraph {
            /**
             * @param {HtmlElement} svg the svg to draw in
             * @param {HtmlElement} tooltip the tooltip to display
             * @param {int} cx the center of the graph visualization
             * @param {int} cy the center of the graph visualization
             */
            constructor(svg, tooltip, cx, cy) {
                this.svg = svg;
                this.tooltip = tooltip;
                this.cx = cx;
                this.cy = cy;
            }

            /**
             * @param {int} time the value of the node
             * 
             * @returns {float} the time scaled at an adequate value
             */
            get_correct_time(time) {
                return time / 10
            }

            /**
             * @param {float} time the time scaled to an adequate value
             *
             * @returns {float} the radius of the node
             */
            get_radius(time) {
                return Math.sqrt(this.get_correct_time(time) / Math.PI)
            }

            /**
             * @param {int} sec the number of seconds to convert
             * 
             * @returns {string} a string with time in hours, minutes and seconds
             */ 
            seconds_to_time(sec) {
                let h = Math.floor(sec / 3600)
                let hs = h > 0 ? h + "h " : ""
                sec = sec % 3600;
                let m = Math.floor(sec / 60)
                let ms = m > 0 ? m + "m " : ""
                let ss = (sec % 60) + "s"

                return hs + ms + ss
            }

            /**
             * Set the opcaity of nodes and links according to their connections with node
             * 
             * @param {Object} node the node pointed by the mouse
             * @param {Objects} nodes the nodes in the graph
             * @param {Objects} links the links in the graph
             */ 
            mouse_over(node, nodes, links) {
                let to_keep = new Set()

                // Set smaller opacity for links not connected to node
                // Build the list of nodes to keep
                links.filter(d => {
                        let f = d.source.id != node.id && d.target.id != node.id && d.value > 0;
                        if (!f && d.value > 0)
                            to_keep.add(d.source.id == node.id ? d.target.id : d.source.id);

                        return f;
                    })
                     .style("opacity", 0.1)
                
                // Set opacity of nodes to remove
                nodes.filter(d => !to_keep.has(d.id) && d.id != node.id)
                    .style("opacity", 0.1)
            }

            /**
             * Reset opacity to 1 for all graph elements
             * 
             * @param {Objects} nodes the nodes of the graph
             * @param {Objects} links the nodes of the graph
             */
            mouse_out(nodes, links) {
                links.style("opacity", 1)
                nodes.style("opacity", 1)
            }

            /**
             * Draw the graph in the provided svg object
             * 
             * @param {Object} graph the graph to visualize
             */ 
            draw(graph) {
                let that = this

                // Force simulation
                var simulation = d3.forceSimulation()
                                // < 0, linked nodes will attract each other. Default 450
                                .force("link", d3.forceLink().id(d => d.id).distance(d => -20*Math.sqrt(d.value)))
                                // < 0, node will repell nodes around it. Default -500
                                .force("charge", d3.forceManyBody().strength(d => -150*that.get_radius(d.time)))
                                // Center of the graph
                                .force("center", d3.forceCenter(this.cx, this.cy));

                // Link objects
                var link = this.svg.append("g")
                    .attr("class", "links")
                    .selectAll("line")
                    .data(graph.links)
                    .enter().append("line")
                    .attr("stroke-width", d => Math.sqrt(d.value));

                // Node objects
                var node = this.svg.append("g")
                    .attr("class", "nodes")
                    .selectAll("g")
                    .data(graph.nodes)
                    .enter().append("g")
                    // Drag interaction
                    .call(d3.drag()
                        .on("start", function(d) { that.dragstarted(d, simulation) })
                        .on("drag", function(d) { that.dragged(d) })
                        .on("end", function(d) { that.dragended(d, simulation) }))
                    // Hover, out interactions
                    .on('mouseover', d => that.mouse_over(d, node, link))
                    .on('mouseout', d => that.mouse_out(node, link))
                    
                // Circles for the nodes
                var circles = node.append("circle")
                    .attr("r", d => that.get_radius(d.time))
                    .attr("fill", "white")
                    .attr("stroke", "black")

                // Images within the circles
                var images = node.append("image")
                    .attr("xlink:href", d => d.image)
                    .attr("width", d => 2*that.get_radius(d.time))
                    .attr("height", d => 2*that.get_radius(d.time))
                    .attr("x", d => -that.get_radius(d.time))
                    .attr("y", d => -that.get_radius(d.time))

                // Labels below the nodes
                var labels = node.append("text")
                    .text(d => d.id)
                    .attr("text-anchor", "middle")
                    .attr('x', 0)
                    .attr('y', d => that.get_radius(d.time) + 16);

                // Title for each node (stay over a node to see it)
                node.append("title")
                    .text(d => d.id);

                // Apply simulation to nodes
                simulation
                    .nodes(graph.nodes)
                    .on("tick", function() { that.ticked(link, node) });

                // Apply simulation to links
                simulation.force("link")
                    .links(graph.links);
            }

            /**
             * @param {Object} link the link of the node
             * @param {Object} node the node to animate
             */ 
            ticked(link, node) {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("transform", d => "translate(" + d.x + "," + d.y + ")")
            }

            /**
             * @param {Object} d the node object dragged
             * @param {Simulation} simulation the simulation of the forces
             */
            dragstarted(d, simulation) {
                if (!d3.event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            /**
             * @param {Object} d the node object dragged
             */ 
            dragged(d) {
                d.fx = d3.event.x;
                d.fy = d3.event.y;
            }

            /**
             * @param {Object} d the node object dragged
             * @param {Simulation} simulation the simulation of the forces
             */
            dragended(d, simulation) {
                if (!d3.event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        // Request for the dataset
        let xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', '../../../data/dataset.json', true);
        xobj.onreadystatechange = function () {
                if (xobj.readyState == 4 && xobj.status == "200") {
                    // Parse the JSON dataset
                    let data = JSON.parse(xobj.responseText)
                    // Filter unwanted data
                    let f = d => d['App Name'] != "Screen off" && !d['App Name'].startsWith("Screen on") // && d['User_ID'] == 2
                    data = data.filter(f)

                    // Build the logical representation of the model
                    let acm = new AppChordModel(data, 10)
                    // Apply last filters
                    acm.apply_filters(60, 1e10, 0.1, 1)

                    // Build the visualization
                    ag = new AppGraph(svg, tooltip, 500, 500)
                    console.log(acm.get_as_json())
                    ag.draw(acm.get_as_json())
                }
        };
        xobj.send(null);
    </script>
</body>
