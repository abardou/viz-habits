<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <style>
    body { margin:0;position:fixed;top:0;right:0;bottom:0;left:0; }
    .hidden {
        display: none;
    }
    div.tooltip {
        color: #222;
        background-color: #fff;
        padding: .5em;
        text-shadow: #f5f5f5 0 1px 0;
        border-radius: 2px;
        opacity: 0.9;
        position: absolute;
    }
    .links line {
        stroke: #999;
        stroke-opacity: 0.6;
    }

    .nodes circle {
        stroke: #fff;
        stroke-width: 1.5px;
    }

    text {
        font-family: sans-serif;
        font-size: 0.85em;
    }
  </style>
</head>

<body>
    <script src="../../../viz/js/data/appchord_model.js"></script>
    <script>
        // Svg variable
        var svg = d3.select("body").append("svg")
                    .attr("width", 1000)
                    .attr("height", 1000);
        
        // Tooltip div
        var tooltip = d3.select('body').append('div').attr('class', 'hidden tooltip');

        function get_size(time) {
            return Math.pow(time, 1/3)
        }

        function draw(graph) {
            var simulation = d3.forceSimulation()
                            .force("link", d3.forceLink().id(function(d) { return d.id; }).distance(450))
                            .force("charge", d3.forceManyBody())
                            .force("center", d3.forceCenter(500, 500));

            var link = svg.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(graph.links)
                .enter().append("line")
                .attr("stroke-width", function(d) { return Math.sqrt(d.value); });

            var node = svg.append("g")
                .attr("class", "nodes")
                .selectAll("g")
                .data(graph.nodes)
                .enter().append("g")
                
            var circles = node.append("circle")
                .attr("r", d => get_size(d.time))
                // .attr("fill", function(d) { return color(d.group); })
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            var lables = node.append("text")
                .text(function(d) {
                    return d.id;
                })
                .attr("text-anchor", "middle")
                .attr('x', 0)
                .attr('y', d => get_size(d.time) + 16);

            node.append("title")
                .text(function(d) { return d.id; });

            simulation
                .nodes(graph.nodes)
                .on("tick", ticked);

            simulation.force("link")
                .links(graph.links);

            function ticked() {
                link
                    .attr("x1", function(d) { return d.source.x; })
                    .attr("y1", function(d) { return d.source.y; })
                    .attr("x2", function(d) { return d.target.x; })
                    .attr("y2", function(d) { return d.target.y; });

                node
                    .attr("transform", function(d) {
                    return "translate(" + d.x + "," + d.y + ")";
                    })
            }

            function dragstarted(d) {
                if (!d3.event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(d) {
                d.fx = d3.event.x;
                d.fy = d3.event.y;
            }

            function dragended(d) {
                if (!d3.event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        let xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', '../../../data/dataset.json', true);
        xobj.onreadystatechange = function () {
                if (xobj.readyState == 4 && xobj.status == "200") {
                    let data = JSON.parse(xobj.responseText)
                    let f = d => d['App Name'] != "Screen off" && !d['App Name'].startsWith("Screen on") //&& d['User_ID'] == 3
                    data = data.filter(f)
                    let acm = new AppChordModel(data, 10)
                    acm.apply_filters(60, 1e10, 0.05, 1)

                    draw(acm.get_as_json())
                }
        };
        xobj.send(null);
    </script>
</body>
