<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <style>
    body { margin:0;position:fixed;top:0;right:0;bottom:0;left:0; }
    .hidden {
        display: none;
    }
    div.tooltip {
        color: #222;
        background-color: #fff;
        padding: .5em;
        text-shadow: #f5f5f5 0 1px 0;
        border-radius: 2px;
        opacity: 0.9;
        position: absolute;
    }
    .links line {
        stroke: #999;
        stroke-opacity: 0.6;
    }

    .nodes circle {
        stroke: #fff;
        stroke-width: 1.5px;
    }

    text {
        font-family: sans-serif;
        font-size: 0.85em;
    }
  </style>
</head>

<body>
    <script src="../../../viz/js/data/appchord_model.js"></script>
    <script>
        // Svg variable
        var svg = d3.select("body").append("svg")
                    .attr("width", 1000)
                    .attr("height", 1000);
        
        // Tooltip div
        var tooltip = d3.select('body').append('div').attr('class', 'hidden tooltip');

        class AppGraph {
            constructor(svg, tooltip, cx, cy) {
                this.svg = svg;
                this.tooltip = tooltip;
                this.cx = cx;
                this.cy = cy;
            }

            get_size(time) {
                return Math.sqrt(time / (10 * Math.PI))
            }

            seconds_to_time(sec) {
                let h = Math.floor(sec / 3600)
                let hs = h > 0 ? h + "h " : ""
                sec = sec % 3600;
                let m = Math.floor(sec / 60)
                let ms = m > 0 ? m + "m " : ""
                let ss = (sec % 60) + "s"

                return hs + ms + ss
            }

            draw(graph) {
                let that = this

                var simulation = d3.forceSimulation()
                                .force("link", d3.forceLink().id(d => d.id).distance(d => -d.value)) // 450
                                .force("charge", d3.forceManyBody().strength(-4000)) // -500
                                .force("center", d3.forceCenter(this.cx, this.cy));

                var link = this.svg.append("g")
                    .attr("class", "links")
                    .selectAll("line")
                    .data(graph.links)
                    .enter().append("line")
                    .attr("stroke-width", d => Math.sqrt(d.value));

                var node = this.svg.append("g")
                    .attr("class", "nodes")
                    .selectAll("g")
                    .data(graph.nodes)
                    .enter().append("g")
                    
                var circles = node.append("circle")
                    .attr("r", d => that.get_size(d.time))
                    // .attr("fill", function(d) { return color(d.group); })
                    .call(d3.drag()
                        .on("start", function(d) { that.dragstarted(d, simulation) })
                        .on("drag", function(d) { that.dragged(d) })
                        .on("end", function(d) { that.dragended(d, simulation) }))

                var lables = node.append("text")
                    .text(d => d.id)
                    .attr("text-anchor", "middle")
                    .attr('x', 0)
                    .attr('y', d => that.get_size(d.time) + 16);

                node.append("title")
                    .text(d => d.id);

                simulation
                    .nodes(graph.nodes)
                    .on("tick", function() { that.ticked(link, node) });

                simulation.force("link")
                    .links(graph.links);
            }

            ticked(link, node) {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("transform", d => "translate(" + d.x + "," + d.y + ")")
            }

            dragstarted(d, simulation) {
                if (!d3.event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            dragged(d) {
                d.fx = d3.event.x;
                d.fy = d3.event.y;
            }

            dragended(d, simulation) {
                if (!d3.event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        let xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', '../../../data/dataset.json', true);
        xobj.onreadystatechange = function () {
                if (xobj.readyState == 4 && xobj.status == "200") {
                    let data = JSON.parse(xobj.responseText)
                    let f = d => d['App Name'] != "Screen off" && !d['App Name'].startsWith("Screen on") && d['User_ID'] == 1
                    data = data.filter(f)
                    let acm = new AppChordModel(data, 10)
                    acm.apply_filters(300, 1e10, 0.05, 1)

                    ag = new AppGraph(svg, tooltip, 500, 500)
                    ag.draw(acm.get_as_json())
                }
        };
        xobj.send(null);
    </script>
</body>
