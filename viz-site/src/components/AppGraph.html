<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <style>
    body { margin:0;position:fixed;top:0;right:0;bottom:0;left:0; }
    .hidden {
        display: none;
    }
    div.tooltip {
        color: #222;
        background-color: #fff;
        padding: .5em;
        text-shadow: #f5f5f5 0 1px 0;
        border-radius: 2px;
        opacity: 0.9;
        position: absolute;
    }

    .links line {
        stroke: #CCC;
    }

    text {
        font-family: sans-serif;
        font-size: 0.85em;
    }
  </style>
</head>

<body>
    <script src="../../../viz/js/data/appchord_model.js"></script>
    <script>
        // Svg variable
        var svg = d3.select("body").append("svg")
                    .attr("width", 1000)
                    .attr("height", 1000);
        
        // Tooltip div
        var tooltip = d3.select('body').append('div').attr('class', 'hidden tooltip');

        class AppGraph {
            constructor(svg, tooltip, cx, cy) {
                this.svg = svg;
                this.tooltip = tooltip;
                this.cx = cx;
                this.cy = cy;
            }

            get_correct_time(time) {
                return time / 10
            }

            get_size(time) {
                return Math.sqrt(this.get_correct_time(time) / Math.PI)
            }

            seconds_to_time(sec) {
                let h = Math.floor(sec / 3600)
                let hs = h > 0 ? h + "h " : ""
                sec = sec % 3600;
                let m = Math.floor(sec / 60)
                let ms = m > 0 ? m + "m " : ""
                let ss = (sec % 60) + "s"

                return hs + ms + ss
            }

            mouse_over(node, nodes, links) {
                let to_keep = new Set()

                links.filter(d => {
                        let f = d.source.id != node.id && d.target.id != node.id && d.value > 0;
                        if (!f && d.value > 0)
                            to_keep.add(d.source.id == node.id ? d.target.id : d.source.id);

                        return f;
                    })
                     .style("opacity", 0.1)
                
                nodes.filter(d => !to_keep.has(d.id) && d.id != node.id)
                    .style("opacity", 0.1)
            }

            mouse_out(nodes, links) {
                links.style("opacity", 1)
                nodes.style("opacity", 1)
            }

            draw(graph) {
                let that = this

                var simulation = d3.forceSimulation()
                                .force("link", d3.forceLink().id(d => d.id).distance(d => -20*Math.sqrt(d.value))) // 450
                                .force("charge", d3.forceManyBody().strength(d => -150*that.get_size(d.time))) // -500
                                .force("center", d3.forceCenter(this.cx, this.cy));

                var link = this.svg.append("g")
                    .attr("class", "links")
                    .selectAll("line")
                    .data(graph.links)
                    .enter().append("line")

                    .attr("stroke-width", d => Math.sqrt(d.value));

                var node = this.svg.append("g")
                    .attr("class", "nodes")
                    .selectAll("g")
                    .data(graph.nodes)
                    .enter().append("g")
                    .call(d3.drag()
                        .on("start", function(d) { that.dragstarted(d, simulation) })
                        .on("drag", function(d) { that.dragged(d) })
                        .on("end", function(d) { that.dragended(d, simulation) }))
                    .on('mouseover', d => that.mouse_over(d, node, link))
                    .on('mouseout', d => that.mouse_out(node, link))
                    
                var circles = node.append("circle")
                    .attr("r", d => that.get_size(d.time))
                    .attr("fill", "white")
                    .attr("stroke", "black")

                // Images
                var images = node.append("image")
                    .attr("xlink:href", d => d.image)
                    .attr("width", d => 2*that.get_size(d.time))
                    .attr("height", d => 2*that.get_size(d.time))
                    .attr("x", d => -that.get_size(d.time))
                    .attr("y", d => -that.get_size(d.time))

                var lables = node.append("text")
                    .text(d => d.id)
                    .attr("text-anchor", "middle")
                    .attr('x', 0)
                    .attr('y', d => that.get_size(d.time) + 16);

                node.append("title")
                    .text(d => d.id);

                simulation
                    .nodes(graph.nodes)
                    .on("tick", function() { that.ticked(link, node) });

                simulation.force("link")
                    .links(graph.links);
            }

            ticked(link, node) {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("transform", d => "translate(" + d.x + "," + d.y + ")")
            }

            dragstarted(d, simulation) {
                if (!d3.event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            dragged(d) {
                d.fx = d3.event.x;
                d.fy = d3.event.y;
            }

            dragended(d, simulation) {
                if (!d3.event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        let xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', '../../../data/dataset.json', true);
        xobj.onreadystatechange = function () {
                if (xobj.readyState == 4 && xobj.status == "200") {
                    let data = JSON.parse(xobj.responseText)
                    let f = d => d['App Name'] != "Screen off" && !d['App Name'].startsWith("Screen on") // && d['User_ID'] == 2
                    data = data.filter(f)


                    let acm = new AppChordModel(data, 10)
                    acm.apply_filters(60, 1e10, 0.1, 1)

                    ag = new AppGraph(svg, tooltip, 500, 500)
                    console.log(acm.get_as_json())
                    ag.draw(acm.get_as_json())
                }
        };
        xobj.send(null);
    </script>
</body>
