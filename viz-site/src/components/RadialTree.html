<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <style>
    body { margin:0;position:fixed;top:0;right:0;bottom:0;left:0; }
    .hidden {
        display: none;
    }
    div.tooltip {
        color: #222;
        background-color: #fff;
        padding: .5em;
        text-shadow: #f5f5f5 0 1px 0;
        border-radius: 2px;
        opacity: 0.9;
        position: absolute;
    }
    .node circle {
      fill: #fff;
      stroke: steelblue;
      stroke-width: 3px;
    }

    .node text {
      font: 12px sans-serif;
    }

    .link {
      fill: none;
      stroke: #ccc;
      stroke-width: 2px;
    }

    text {
        font-family: sans-serif;
        font-size: 0.85em;
    }
  </style>
</head>

<body>
    <script src="../../../viz/js/data/radialtree_model.js"></script>
    <script>
        
    

        class RadialTree {
            constructor(cx, cy) {
                this.cx = cx;
                this.cy = cy;
            }

            get_correct_time(time) {
                return time / 10
            }

            get_size(time) {
                return Math.sqrt(this.get_correct_time(time) / Math.PI)
            }

            seconds_to_time(sec) {
                let h = Math.floor(sec / 3600)
                let hs = h > 0 ? h + "h " : ""
                sec = sec % 3600;
                let m = Math.floor(sec / 60)
                let ms = m > 0 ? m + "m " : ""
                let ss = (sec % 60) + "s"

                return hs + ms + ss
            }

            draw_den(data) {

                let that = this

                let width = 975
                let radius = width / 2
                let tree = d3.cluster().size([2 * Math.PI, radius - 100])

                const root = tree(d3.hierarchy(data)
                    .sort((a, b) => d3.ascending(a.data.name, b.data.name)));

                

                const svg = d3.select("body").append("svg")
                    .style("max-width", "100%")
                    .style("height", "auto")
                    .style("font", "10px sans-serif")
                    .style("margin", "5px");

                let tooltip = svg.append('div').attr('class', 'hidden tooltip');
                  
                const link = svg.append("g")
                    .attr("id", "links")
                    .attr("fill", "none")
                    .attr("stroke", "#555")
                    .attr("stroke-opacity", 0.4)
                    .attr("stroke-width", 1.5)
                    .selectAll("path")
                    .data(root.links())
                    .enter().append("path")
                    .attr("d", d3.linkRadial()
                        .angle(d => d.x)
                        .radius(d => d.y))
                    .on("mousmove", function(d) {
                    // on affiche le toolip
                        tooltip.classed('hidden', false)
                            // on positionne le tooltip
                            .attr('style', 'left:' + (d.x + 15) +
                                'px; top:' + (d.y - 15) + 'px')
                            // on recupere le nom de l'etat 
                            .html(d.data.name);
                        })
                    .on('mouseout', function() {
                        // on cache le toolip
                        tooltip.classed('hidden', true);
                        });

                  
                const node = svg.append("g")
                    .attr("id", "nodes")
                    .attr("stroke-linejoin", "round")
                    .attr("stroke-width", 3)
                    .selectAll("g")
                    .data(root.descendants().reverse())
                    .enter().append("g")
                    .attr("transform", d => `
                        rotate(${d.x * 180 / Math.PI - 90})
                        translate(${d.y},0)
                    `)
                    .on('mouseover', function(d) {
                        let center_x = -parseFloat(svg.attr("viewBox").split(',')[0])
                        let center_y = -parseFloat(svg.attr("viewBox").split(',')[1])

                        
                        
                        let children = []
                        let parents = []

                        d3.select("#nodes").selectAll("g")
                            .each(function(e) {

                                if (d.data.name == e.data.name) {
                                    
                                    children = children.concat(that.get_all_children(e))
                                    parents = parents.concat(that.get_all_parents(e))
                                }
                            });


                        let up_app = []
                        
                        d3.select("#nodes").selectAll("g")
                            .attr("opacity", function(e) {

                                if (!parents.includes(e) && !children.includes(e)) {
                                    return 0.2
                                }
                                up_app.push(e)
                                return 1
                                
                            });


                        d3.select("#links").selectAll("path")
                            .attr("opacity", function(e) {

                                if (up_app.includes(e.target)) {
                                    return 1
                                }
                                return 0.2
                            });

                
                    })
                    .on('mouseout', function() {
                              // on cache le toolip
                        //tooltip.classed('hidden', true);

                        d3.selectAll("#nodes").selectAll("g")
                            .attr("opacity", function(e) {
                                return 1
                            })


                        d3.selectAll("#links").selectAll("path")
                            .attr("opacity", function(e) {
                                return 1
                            })
                    });
                  
                node.append("circle")
                    .attr("fill", d => d.children ? "#555" : "#999")
                    .attr("r", 2.5);

                const images = node.append("image")
                    .attr("xlink:href", d => d.data.image)
                    .attr("width", 20)
                    .attr("height", 20)
                    .attr("x", -10)
                    .attr("y", -10)
                  
                svg.attr("viewBox", autoBox);

                  

                function autoBox() {
                  const {x, y, width, height} = this.getBBox();
                  return [x, y, width*2, height*2];
                }

            }

            get_all_parents(d) {
                let res = []

                while (d.parent != null) {
                    res.push(d.parent)
                    d = d.parent
                }

                return res
            }

            get_all_children(d) {
                let res = []
                res.push(d)
            
                if (d.children != undefined) {
                    for (let c of d.children) {
                        let chi = this.get_all_children(c)
                        
                        res = res.concat(chi)
                        
                    }
                }
                return res
            }

            draw_in_line(tree) {
                let that = this

                var width = 960, height = 500

                // Set the dimensions and margins of the diagram
                var margin = {top: 20, right: 90, bottom: 30, left: 90},
                    width = 960 - margin.left - margin.right,
                    height = 500 - margin.top - margin.bottom;
                // Feel free to change or delete any of the code you see in this editor!
                var svg = d3.select("body").append("svg")
                    .attr("width", width + margin.right + margin.left)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform", "translate("
                          + margin.left + "," + margin.top + ")");

                var i = 0,
                    duration = 750,
                    root;

                var tree = d3.layout.tree()
                    .size([360, diameter / 2 - 190])
                    .separation(function(a, b) { return (a.parent == b.parent ? 1 : 2) / a.depth; });

                var diagonal = d3.svg.diagonal.radial()
                    .projection(function(d) { return [d.y, d.x / 180 * Math.PI]; });


                // declares a tree layout and assigns the size
                var treemap = d3.tree().size([height, width]);

                // load the external data
    
                // Assigns parent, children, height, depth
                root = d3.hierarchy(tree, function(d) { return d.children; });
                root.x0 = height / 2;
                root.y0 = 0;

                // Collapse after the second level
                root.children.forEach(collapse);
                

                update(root);

                // Collapse the node and all it's children
                function collapse(d) {
                  if(d.children) {
                    d._children = d.children
                    d._children.forEach(collapse)
                    d.children = null
                  }
                }

                function update(source) {

                  // Assigns the x and y position for the nodes
                  var treeData = treemap(root);

                  // Compute the new tree layout.
                  var nodes = treeData.descendants(),
                      links = treeData.descendants().slice(1);

                  // Normalize for fixed-depth.
                  nodes.forEach(function(d){ d.y = d.depth * 180});

                  // ****************** Nodes section ***************************

                  // Update the nodes...
                  var node = svg.selectAll('g.node')
                      .data(nodes, function(d) {return d.id || (d.id = ++i); });

                  // Enter any new modes at the parent's previous position.
                  var nodeEnter = node.enter().append('g')
                      .attr('class', 'node')
                      .attr("transform", function(d) {
                        return "translate(" + source.y0 + "," + source.x0 + ")";
                    })
                    .on('click', click);

                  // Add Circle for the nodes
                  nodeEnter.append('circle')
                      .attr('class', 'node')
                      .attr('r', 1e-6)
                      .style("fill", function(d) {
                          return d._children ? "lightsteelblue" : "#fff";
                      });

                  // Add labels for the nodes
                  nodeEnter.append('text')
                      .attr("dy", ".35em")
                      .attr("x", function(d) {
                          return d.children || d._children ? -13 : 13;
                      })
                      .attr("text-anchor", function(d) {
                          return d.children || d._children ? "end" : "start";
                      })
                      .text(function(d) { return d.data.name; });

                  // UPDATE
                  var nodeUpdate = nodeEnter.merge(node);

                  // Transition to the proper position for the node
                  nodeUpdate.transition()
                    .duration(duration)
                    .attr("transform", function(d) { 
                        return "translate(" + d.y + "," + d.x + ")";
                     });

                  // Update the node attributes and style
                  nodeUpdate.select('circle.node')
                    .attr('r', 10)
                    .style("fill", function(d) {
                        return d._children ? "lightsteelblue" : "#fff";
                    })
                    .attr('cursor', 'pointer');


                  // Remove any exiting nodes
                  var nodeExit = node.exit().transition()
                      .duration(duration)
                      .attr("transform", function(d) {
                          return "translate(" + source.y + "," + source.x + ")";
                      })
                      .remove();

                  // On exit reduce the node circles size to 0
                  nodeExit.select('circle')
                    .attr('r', 1e-6);

                  // On exit reduce the opacity of text labels
                  nodeExit.select('text')
                    .style('fill-opacity', 1e-6);

                  // ****************** links section ***************************

                  // Update the links...
                  var link = svg.selectAll('path.link')
                      .data(links, function(d) { return d.id; });

                  // Enter any new links at the parent's previous position.
                  var linkEnter = link.enter().insert('path', "g")
                      .attr("class", "link")
                      .attr('d', function(d){
                        var o = {x: source.x0, y: source.y0}
                        return diagonal(o, o)
                      });

                  // UPDATE
                  var linkUpdate = linkEnter.merge(link);

                  // Transition back to the parent element position
                  linkUpdate.transition()
                      .duration(duration)
                      .attr('d', function(d){ return diagonal(d, d.parent) });

                  // Remove any exiting links
                  var linkExit = link.exit().transition()
                      .duration(duration)
                      .attr('d', function(d) {
                        var o = {x: source.x, y: source.y}
                        return diagonal(o, o)
                      })
                      .remove();

                  // Store the old positions for transition.
                  nodes.forEach(function(d){
                    d.x0 = d.x;
                    d.y0 = d.y;
                  });

                  // Creates a curved (diagonal) path from parent to the child nodes
                  function diagonal(s, d) {

                    var path = `M ${s.y} ${s.x}
                            C ${(s.y + d.y) / 2} ${s.x},
                              ${(s.y + d.y) / 2} ${d.x},
                              ${d.y} ${d.x}`

                    return path
                  }

                  // Toggle children on click.
                  function click(d) {
                    if (d.children) {
                        d._children = d.children;
                        d.children = null;
                      } else {
                        d.children = d._children;
                        d._children = null;
                      }
                    update(d);
                  }
            }
        }

            ticked(link, node) {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("transform", d => "translate(" + d.x + "," + d.y + ")")
            }

            dragstarted(d, simulation) {
                if (!d3.event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            dragged(d) {
                d.fx = d3.event.x;
                d.fy = d3.event.y;
            }

            dragended(d, simulation) {
                if (!d3.event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        let xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', '../../../data/dataset.json', true);
        xobj.onreadystatechange = function () {
                if (xobj.readyState == 4 && xobj.status == "200") {
                    let data = JSON.parse(xobj.responseText)

                    let rtm = new RadialTreeModel(data, 10)
                    //rtm.apply_filters(0, 1e10, 0.05, 1)

                    rt = new RadialTree(500, 500)
                    rt.draw_den(rtm.get_tree("3", ))
                }
        };
        xobj.send(null);
    </script>
</body>
